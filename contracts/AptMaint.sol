pragma solidity ^0.6.0;
pragma experimental ABIEncoderV2;

contract apartmentMaintainance {
    
    //structure to capture the flat details
    
    struct ownerDetails
    {
        address id;            //flat owner id
        uint16 flatno;         //flat number
        uint16 flat_sqft;      //flat square feet area
        string ownername;      //flat owner name
        string tenantname;     //flat tenant name
        address tenantaddress; //flat tenant id
        bool status;           //verified by Executor status (true or false)
        string ipfshashdocs;  //Hash of IPFS upload (for ex: Qme91EGgm9JtvRwf8hXLkhQATX1vpmNDS6Brd79VpjHg5g)
    }
    
     
    mapping(uint16 => ownerDetails) private details;  //map flat number to ownerdetails structure
    uint16[] internal flatList;                       //array of flat numbers list
    uint16 private flatCount;                         //capture total number of flats count
    address payable public requestExecutor;           //capture Executor of contract(Admin)
    uint16 public sqftPrice;                                 //capture maintainance price per one square feet area
    mapping(uint16=>bool) public maintPaymentsList;   //map flat number to boolean values whether maintainance paid or not (true or false)
    uint16[] internal maintPaymentFlatList;           //array of flat numbers list who paid maintainance
    uint16 public paymentsCount;                      //capture total number of flat owners count who paid the maintainance, same people are eligible for approving the requests
    
    // structure to generate Requests and take voting of flat owners and release the payment for approved requests
    
    struct paymentRequest 
    {
     string requestid;                    //request id for payment to be made
     string requestdescr;                 //request description
     uint16 value;                        //Total value to be paid
     address payable recipient;           //whom should the payment to be made to
     bool complete;                       //payment made or not (true or false)
     uint16 approvalcount;                //capture the count of approvals received for request id
     mapping(address => bool) approvals;  //map owner id to boolean values to check if they had provided the approval for request id for payment
    }
   
    paymentRequest[] public paymentRequests;               //array of payment requests generated by executor (Admin)
    mapping(string => paymentRequest) private requests;    //map request id's with payment requests list
   
   //emit events once the actions are triggered and completed
   
    event UserUpdated(uint16 flatId, string ownername, string message);
    event UserAdded(uint16 flatId, string ownername, string message);
    event UserUpdatedFailed(uint16 flatId, string ownername, string message);
    event UserApproved(uint flatId, string message);
    
   // update the executor id(Admin) of this contract in the constructor
    constructor(uint16 _sqftPrice) public{
     requestExecutor = msg.sender;    
     sqftPrice = _sqftPrice;
    }
    
   // create modifers for executor and non executor functions
    modifier notExecutor()
    {
     require (msg.sender != requestExecutor, "This function should not be triggered by Executor");
     _;
    }
    modifier Executor()
    {
       require (msg.sender == requestExecutor, "This function should only be triggered by Executor");
     _; 
    }
    
   // function to add Ownerdetails and this function can only be executed by the owner but not executor (Admin)
     
    function addUser(uint16 fno, uint16 fsqft, string memory uname, string memory _ipfshash) public notExecutor
    {
        ownerDetails memory ownerdetails;
        require (details[fno].flatno == 0, "Flat number already registered");
            ownerdetails.flatno = fno;
            ownerdetails.flat_sqft = fsqft;
            ownerdetails.ownername = uname;
            ownerdetails.tenantname = uname;
            ownerdetails.tenantaddress = msg.sender;
            ownerdetails.status = false;
            ownerdetails.id = msg.sender;
            ownerdetails.ipfshashdocs = _ipfshash;
            details[fno] = ownerdetails;
            flatList.push(fno);
            flatCount++;
            emit UserAdded(fno, uname, "user added successfully");  //emit add user event
    }
    
   // function to modify owner details like owner name, tenant name, tenant address and document hash from IPFS and this function is executed by owner but not executor (Admin)
   
    function modifyUser(uint16 fno, string memory _ownername, string memory _tenantname, address tenantadd) public  notExecutor
    {
        ownerDetails memory ownerdetails;
        ownerdetails = details[fno];
       if (details[fno].id == msg.sender || details[fno].tenantaddress == msg.sender ) {
            ownerdetails.ownername = _ownername;
            ownerdetails.tenantname = _tenantname;
            if (ownerdetails.tenantaddress != tenantadd)
            {
            ownerdetails.tenantaddress = tenantadd;
            }
            ownerdetails.id = msg.sender;
            ownerdetails.status = false;
            details[fno] = ownerdetails;
            emit UserUpdated(fno, _ownername, "user updated successfully"); //emit update user event
        }
        else if (details[fno].flatno != fno || details[fno].id != msg.sender)
        {
            emit UserUpdatedFailed(fno, _ownername, "Flat not registerd or not a valid owner for update"); //emit update user failed
        }
    } 
    
   // function to validate newly or modified owner details by Executor and approve or deny the same.
    function approveNewModiferUser(uint16 fno) public Executor
    {
        ownerDetails memory ownerdetails;
        ownerdetails = details[fno];
        ownerdetails.status = true;
        details[fno] = ownerdetails;
        emit UserApproved(fno,'Flat details approved by Admin after Verification');  //emit user details approved by Executor
    }
    
   // function to get and display all list of owner details, can be accessed only by Executor
    function getAllUser() public Executor view returns(ownerDetails[] memory)
    {
       uint16 i;
        ownerDetails[] memory ownerdetails = new ownerDetails[](flatCount);
        for (i= 0 ;i<flatCount; i++)
        {
            ownerdetails[i] = details[flatList[i]];
        } 
        return ownerdetails; 
    }
    
   // function to get owner details by flat no
    function getUserById(uint16 detailId) public view returns (ownerDetails memory) {
        return details[detailId];
    }

   // function to change Owner of contract and can be executed only by Executor (Admin)
    function changeOwner(address payable _owner) public Executor
    {
        requestExecutor = _owner;
    }
    
   // function to set square feet price per unit by Executor (Admin)
    function setSqftPrice(uint16 _price) public Executor {
        sqftPrice = _price;
    }    
    
   // function to make maintainance payment by respective approved flat owners or tenants 
   function maintPayment(uint16 fno) public payable {
        
        uint16 maintPrice = details[fno].flat_sqft*sqftPrice;
        
        require((details[fno].id == msg.sender || details[fno].tenantaddress == msg.sender) && details[fno].status == true, "Maintainance Payment can be done by only approved owners or tenants");
        require(msg.value >= maintPrice);
        maintPaymentsList[fno] = true;
        maintPaymentFlatList.push(fno);
        paymentsCount++;
    }
    
   // function to get Balance of contract address
    function getBalance() public view returns (uint){
        return address(this).balance;
    }
    
   // function to create requests by Executor for payments to be made from maintainance amount after approval from maintainance payee's
    function createRequest(string memory reqid, string memory description , uint16 value, address payable recipient) public Executor
    {
     paymentRequest memory newRequest = paymentRequest({
        requestid: reqid,
        requestdescr: description,
        value: value,
        recipient: recipient,
        complete: false,
        approvalcount: 0
     });
     requests[reqid] = newRequest;
     paymentRequests.push(newRequest);
    }
   
  // function to approve requests created by Executor(Admin) by maintainance Payee's
   function approveRequest(uint16 fno, string memory requestid) public  notExecutor
   {
     paymentRequest storage request = requests[requestid];
     
     require(maintPaymentsList[fno],"Maintainance payment not done, hence cannot approve request");
     require(!request.approvals[msg.sender], "Already approved the request, approval should be provided only once");
     
     request.approvals[msg.sender] = true;
     request.approvalcount++;
    }
   
  // function to release payment to vendor by Executor after receving >50% of approvals by maintainance payee's
   function finalizeRequest (string memory requestid) public Executor
   {
   
      paymentRequest storage request = requests[requestid];
      
      require(request.approvalcount > (paymentsCount / 2),"Not received greater than 50% approvals by approvers ");
      require(!requests[requestid].complete, "request id is already completed");
      
      request.recipient.transfer(request.value);
      requests[requestid].complete = true;
    }
    
  // reset maintainance payment list
  function resetMaintainancePaymentList() public Executor
  {
        uint16 i;
        for (i= 0 ;i<paymentsCount; i++)
        {
            delete maintPaymentsList[maintPaymentFlatList[i]];
        } 
        paymentsCount = 0;
  }
  
  //fallback function
    receive() external payable  //fallback function
    {
      
    }
   
  //selfdestruct function
    function kill() public Executor
    {
       selfdestruct(requestExecutor);
    }
}
    
